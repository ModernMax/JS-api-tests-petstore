"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormRequest = exports.JsonRequest = exports.BaseHttpRequest = void 0;
const got_1 = require("got");
class BaseHttpRequest {
    constructor() {
        this.options = {
            http2: true
        };
    }
    prefixUrl(url) {
        this.options.prefixUrl = url;
        return this;
    }
    /**
     * @param url Can be full url, but only in case prefixUrl is not set
     */
    url(url) {
        this.options.url = url;
        return this;
    }
    cookieJar(cookiesJar) {
        this.options.cookieJar = cookiesJar;
        return this;
    }
    method(method) {
        this.options.method = method;
        return this;
    }
    headers(headers) {
        var _a;
        this.options.headers = (_a = this.options.headers) !== null && _a !== void 0 ? _a : {};
        this.options.headers = Object.assign(Object.assign({}, this.options.headers), headers);
        return this;
    }
    bearerToken(bearerToken) {
        return this.headers({
            'Authorization': bearerToken
        });
    }
    searchParams(searchParams) {
        this.options.searchParams = searchParams;
        return this;
    }
    send() {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            // Patching async stacktrace that leads to nowhere
            const stack = new Error().stack;
            try {
                return yield got_1.default(this.options);
            }
            catch (err) {
                err.stack = stack;
                if (err instanceof got_1.default.HTTPError) {
                    err.message = `
                [${(_a = err === null || err === void 0 ? void 0 : err.options) === null || _a === void 0 ? void 0 : _a.method}]: ${(_b = err === null || err === void 0 ? void 0 : err.options) === null || _b === void 0 ? void 0 : _b.url} => ${(_c = err === null || err === void 0 ? void 0 : err.response) === null || _c === void 0 ? void 0 : _c.statusCode} 

                ${err.message} 

                ${(_e = (_d = err === null || err === void 0 ? void 0 : err.response) === null || _d === void 0 ? void 0 : _d.rawBody) === null || _e === void 0 ? void 0 : _e.toString()}
                `;
                }
                throw err;
            }
        });
    }
}
exports.BaseHttpRequest = BaseHttpRequest;
class JsonRequest extends BaseHttpRequest {
    constructor() {
        super();
        this.options = Object.assign(Object.assign({}, this.options), { responseType: "json" });
    }
    body(body) {
        this.options.json = body;
        return this;
    }
}
exports.JsonRequest = JsonRequest;
class FormRequest extends BaseHttpRequest {
    body(form) {
        this.options.form = form;
        return this;
    }
}
exports.FormRequest = FormRequest;
