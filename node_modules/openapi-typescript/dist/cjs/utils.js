"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unrefComponent = exports.tsUnionOf = exports.tsReadonly = exports.tsPartial = exports.tsIntersectionOf = exports.tsTupleOf = exports.tsArrayOf = exports.transformRef = exports.swaggerVersion = exports.nodeType = exports.isRef = exports.comment = void 0;
function comment(text) {
    const commentText = text.trim().replace(/\*\//g, "*\\/");
    if (commentText.indexOf("\n") === -1) {
        return `/** ${commentText} */\n`;
    }
    return `/**
  * ${commentText.replace(/\r?\n/g, "\n  * ")}
  */\n`;
}
exports.comment = comment;
function isRef(obj) {
    return !!obj.$ref;
}
exports.isRef = isRef;
function nodeType(obj) {
    if (!obj || typeof obj !== "object") {
        return undefined;
    }
    if (obj.$ref) {
        return "ref";
    }
    if (Array.isArray(obj.enum) && obj.enum.length) {
        return "enum";
    }
    if (obj.type === "boolean") {
        return "boolean";
    }
    if (["binary", "byte", "date", "dateTime", "password", "string"].includes(obj.type)) {
        return "string";
    }
    if (["double", "float", "integer", "number"].includes(obj.type)) {
        return "number";
    }
    if (obj.type === "array" || obj.items) {
        return "array";
    }
    return "object";
}
exports.nodeType = nodeType;
function swaggerVersion(definition) {
    if ("openapi" in definition) {
        if (parseInt(definition.openapi, 10) === 3) {
            return 3;
        }
    }
    if ("swagger" in definition) {
        if (typeof definition.swagger === "number" && Math.round(definition.swagger) === 2) {
            return 2;
        }
        if (parseInt(definition.swagger, 10) === 2) {
            return 2;
        }
    }
    throw new Error(`üöè version missing from schema; specify whether this is OpenAPI v3 or v2 https://swagger.io/specification`);
}
exports.swaggerVersion = swaggerVersion;
function transformRef(ref, root = "") {
    const isExternalRef = !ref.startsWith("#");
    if (isExternalRef)
        return "any";
    const parts = ref.replace(/^#\//, root).split("/");
    return `${parts[0]}["${parts.slice(1).join('"]["')}"]`;
}
exports.transformRef = transformRef;
function tsArrayOf(type) {
    return `(${type})[]`;
}
exports.tsArrayOf = tsArrayOf;
function tsTupleOf(types) {
    return `[${types.join(", ")}]`;
}
exports.tsTupleOf = tsTupleOf;
function tsIntersectionOf(types) {
    if (types.length === 1)
        return types[0];
    return `(${types.join(") & (")})`;
}
exports.tsIntersectionOf = tsIntersectionOf;
function tsPartial(type) {
    return `Partial<${type}>`;
}
exports.tsPartial = tsPartial;
function tsReadonly(immutable) {
    return immutable ? "readonly " : "";
}
exports.tsReadonly = tsReadonly;
function tsUnionOf(types) {
    if (types.length === 1)
        return `${types[0]}`;
    return `(${types.join(") | (")})`;
}
exports.tsUnionOf = tsUnionOf;
function unrefComponent(components, ref) {
    const [type, object] = ref.match(/(?<=\[")([^"]+)/g);
    return components[type][object];
}
exports.unrefComponent = unrefComponent;
//# sourceMappingURL=utils.js.map