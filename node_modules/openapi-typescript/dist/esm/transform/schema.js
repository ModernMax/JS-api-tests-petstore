import { comment, nodeType, transformRef, tsArrayOf, tsIntersectionOf, tsPartial, tsTupleOf, tsUnionOf, } from "../utils";
export function transformSchemaObjMap(obj, options) {
    const readonly = options.immutableTypes ? "readonly " : "";
    let required = (options && options.required) || [];
    let output = "";
    Object.entries(obj).forEach(([key, value]) => {
        if (value.description)
            output += comment(value.description);
        output += `${readonly}"${key}"${required.includes(key) ? "" : "?"}: `;
        output += transformSchemaObj(value.schema || value, {
            formatter: options.formatter,
            immutableTypes: options.immutableTypes,
            version: options.version,
        });
        output += `;\n`;
    });
    return output.replace(/\n+$/, "\n");
}
export function transformAnyOf(anyOf, options) {
    return tsIntersectionOf(anyOf.map((s) => tsPartial(transformSchemaObj(s, options))));
}
export function transformOneOf(oneOf, options) {
    return tsUnionOf(oneOf.map((value) => transformSchemaObj(value, options)));
}
export function transformSchemaObj(node, options) {
    const readonly = options.immutableTypes ? "readonly " : "";
    let output = "";
    if (node.nullable) {
        output += "(";
    }
    const overriddenType = options.formatter && options.formatter(node);
    if (overriddenType) {
        output += overriddenType;
    }
    else {
        switch (nodeType(node)) {
            case "ref": {
                output += transformRef(node.$ref);
                break;
            }
            case "string":
            case "number":
            case "boolean": {
                output += nodeType(node) || "any";
                break;
            }
            case "enum": {
                const items = [];
                node.enum.forEach((item) => {
                    if (typeof item === "string")
                        items.push(`'${item.replace(/'/g, "\\'")}'`);
                    else if (typeof item === "number" || typeof item === "boolean")
                        items.push(item);
                    else if (item === null && !node.nullable)
                        items.push("null");
                });
                output += tsUnionOf(items);
                break;
            }
            case "object": {
                const isAnyOfOrOneOfOrAllOf = "anyOf" in node || "oneOf" in node || "allOf" in node;
                if (!isAnyOfOrOneOfOrAllOf &&
                    (!node.properties || !Object.keys(node.properties).length) &&
                    !node.additionalProperties) {
                    output += `{ ${readonly}[key: string]: any }`;
                    break;
                }
                let properties = transformSchemaObjMap(node.properties || {}, {
                    immutableTypes: options.immutableTypes,
                    required: node.required,
                    version: options.version,
                });
                let additionalProperties;
                if (node.additionalProperties || (node.additionalProperties === undefined && options.version === 3)) {
                    if ((node.additionalProperties ?? true) === true || Object.keys(node.additionalProperties).length === 0) {
                        additionalProperties = `{ ${readonly}[key: string]: any }`;
                    }
                    else if (typeof node.additionalProperties === "object") {
                        const oneOf = node.additionalProperties.oneOf || undefined;
                        const anyOf = node.additionalProperties.anyOf || undefined;
                        if (oneOf) {
                            additionalProperties = `{ ${readonly}[key: string]: ${transformOneOf(oneOf, options)}; }`;
                        }
                        else if (anyOf) {
                            additionalProperties = `{ ${readonly}[key: string]: ${transformAnyOf(anyOf, options)}; }`;
                        }
                        else {
                            additionalProperties = `{ ${readonly}[key: string]: ${transformSchemaObj(node.additionalProperties, options) || "any"}; }`;
                        }
                    }
                }
                output += tsIntersectionOf([
                    ...(node.allOf ? node.allOf.map((node) => transformSchemaObj(node, options)) : []),
                    ...(node.anyOf ? [transformAnyOf(node.anyOf, options)] : []),
                    ...(node.oneOf ? [transformOneOf(node.oneOf, options)] : []),
                    ...(properties ? [`{\n${properties}\n}`] : []),
                    ...(additionalProperties ? [additionalProperties] : []),
                ]);
                break;
            }
            case "array": {
                if (Array.isArray(node.items)) {
                    output += `${readonly}${tsTupleOf(node.items.map((node) => transformSchemaObj(node, options)))}`;
                }
                else {
                    output += `${readonly}${tsArrayOf(node.items ? transformSchemaObj(node.items, options) : "any")}`;
                }
                break;
            }
        }
    }
    if (node.nullable) {
        output += ") | null";
    }
    return output;
}
//# sourceMappingURL=schema.js.map