"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseValidator = void 0;
const SwaggerParser = require("@apidevtools/swagger-parser");
const URItemplate = require("uri-templates");
const Ajv = require("ajv");
const Errors_1 = require("./Errors");
const defaultOptions = {
    apiPathPrefix: '',
    openApiSpecPath: '',
    ajvOptions: {
        allErrors: true,
        verbose: true,
        jsonPointers: true,
    }
};
class ResponseValidator {
    constructor(options) {
        this.cachedApi = null;
        this.options = {
            ...defaultOptions,
            ...options
        };
    }
    async loadApiDocs() {
        if (this.cachedApi === null) {
            this.cachedApi = await SwaggerParser.dereference(this.options.openApiSpecPath);
        }
        return this.cachedApi;
    }
    async findMatchingPathInDocs(url) {
        const api = await this.loadApiDocs();
        const urlPath = new URL(url).pathname;
        // Direct match, best case
        for (const template of Object.keys(api.paths)) {
            if (`${this.options.apiPathPrefix}${template}` === urlPath) {
                return { [template]: api.paths[template] };
            }
        }
        const matchingPaths = Object.keys(api.paths).filter(template => {
            try {
                const templatePath = `${this.options.apiPathPrefix}${template}`;
                // Number of path sections is not matches
                if (templatePath.split('/').length !== urlPath.split('/').length) {
                    return false;
                }
                return URItemplate(templatePath).test(urlPath);
            }
            catch (err) {
                return false;
            }
        }).filter(path => path !== null && path !== undefined);
        if (matchingPaths.length === 0) {
            throw new Errors_1.UrlIsNotDescribedInOpenApiError(url);
        }
        return Object.fromEntries(matchingPaths.map(pth => [pth, api.paths[pth]]));
    }
    async assertResponse(response) {
        if (!response) {
            throw new Error('response argument is not defined. This is testing framework issue, not real bug');
        }
        const matchingPaths = await this.findMatchingPathInDocs(response.requestUrl);
        const schemas = Object.values(matchingPaths)
            .map(pathObj => { var _a, _b; return (_b = (_a = pathObj[response.method.toLowerCase()]) === null || _a === void 0 ? void 0 : _a.responses[response.statusCode]) === null || _b === void 0 ? void 0 : _b.schema; })
            .filter(schema => schema !== undefined && schema !== null);
        if (schemas.length === 0) {
            throw new Errors_1.JSONSchemaMissingError(response);
        }
        if (schemas.length > 1) {
            throw new Errors_1.MultipleJSONSchemasDefinedError(response);
        }
        const schema = schemas[0];
        const ajv = new Ajv(this.options.ajvOptions);
        let validate;
        try {
            validate = ajv.compile(schema);
        }
        catch (jsonSchemaCompilationError) {
            throw new Errors_1.JSONSchemaCannotBeCompiledError(response, jsonSchemaCompilationError);
        }
        const valid = await validate(response.body);
        if (!valid) {
            throw new Errors_1.ResponseDoesNotMatchJSONSchemaError({
                response: {
                    method: response.method,
                    requestUrl: response.requestUrl,
                    statusCode: response.statusCode,
                    body: response.body,
                },
                schema: schema,
                validationErrors: validate.errors
            });
        }
    }
}
exports.ResponseValidator = ResponseValidator;
//# sourceMappingURL=ResponseValidator.js.map